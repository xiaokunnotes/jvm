<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<title>第四部分 G1（Garbage First）收集器</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="assets/css/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_第四部分_g1garbage_first收集器">1. 第四部分 G1（Garbage First）收集器</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_第四部分_g1garbage_first收集器"><a class="anchor" href="#_第四部分_g1garbage_first收集器"></a>1. 第四部分 G1（Garbage First）收集器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>G1收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器 <code>面向局部收集的设计思路和基于Region的内存布局形式</code> 。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>开启选项：-XX:+UseG1GC</pre>
</div>
</div>
<div class="sect2">
<h3 id="_分区"><a class="anchor" href="#_分区"></a>1.1. 分区</h3>
<div class="paragraph">
<p>G1采用了分区(Region)的思路，不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间，收集器能够对扮演不同角色的Region采用不同的策略去处理。启动时可以通过参数-XX:G1HeapRegionSize=n可指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区。</p>
</div>
<div class="paragraph">
<p>Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个
Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数-XX：G1HeapRegionSize设
定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，
将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代
的一部分来进行看待</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/g1.png" alt="g1">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_卡片"><a class="anchor" href="#_卡片"></a>1.2. 卡片</h3>
<div class="paragraph">
<p>在每个分区内部又被分成了若干个大小为512 Byte卡片，标识堆内存最小可用粒度。所有分区的卡片将会记录在全局卡片表(Global Card Table)中，分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象(见RSet)。每次对内存的回收，都是对指定分区的卡片进行处理。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/g1Card.png" alt="g1Card">
</div>
</div>
<div class="sect3">
<h4 id="_特点"><a class="anchor" href="#_特点"></a>1.2.1. 特点</h4>
<div class="ulist">
<ul>
<li>
<p><strong>用户可指定期望的停顿时间</strong></p>
<div class="literalblock">
<div class="content">
<pre> G1收集器之所以能建立起可预测的停顿时间模型是因为它将Region作为单次回收的最小单元，既每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集，更具体的处理思路是让G1收集器去跟踪各个Region里面的垃
圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一
个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默
认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来</pre>
</div>
</div>
</li>
<li>
<p><strong>追求能够应付应用的内存分配速率，而不追求一次把整个Java堆全部清理干净</strong></p>
<div class="literalblock">
<div class="content">
<pre>  在G1收集器出现之前的所有 其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老 年代（Major GC），再要么就是整个Java堆（Full GC）。 而G1跳出了这个樊笼，它可以面向堆内存任
何部分来组成回收集进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式</pre>
</div>
</div>
</li>
<li>
<p>并行性：G1在回收期间，可以由多个GC线程同时工作，有效利用多核计算能力</p>
</li>
<li>
<p>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，一般来说，不会在整个回收期间完全阻塞应用程序。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_设计思路"><a class="anchor" href="#_设计思路"></a>1.2.2. 设计思路</h4>
<div class="ulist">
<ul>
<li>
<p><strong>将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决？</strong></p>
<div class="ulist">
<ul>
<li>
<p>解决的思路：使用记忆集避免全堆作为GC Roots扫描，但在G1收集器上的记忆集的应用其实要复杂很多，它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。里面存储的元素是卡表的索引号。这
种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更
复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃
圾收集器有着更高的内存占用负担。根据经验，<code>G1至少要耗费大约相当于Java堆容量10%至20%的额
外内存来维持收集器工作</code>。</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？</strong></p>
<div class="ulist">
<ul>
<li>
<p>这里首先是要解决的是用户线程改变对象引用关系时，必须保证其不能打破原本的对象图结构，导致标记结果出现错误，该问题的解决办法是G1收集器通过使用原始快照(SATB)算法来实现的。此外垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上，程序要继续运行就肯定会持续有新对象被创建，G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间
划分出来用于并发回收过程中新对象的分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，既默认它们是存活的，不纳入回收范围。与CMS中
的“Concurrent Mode Failure”失败会导致Full GC类似，如果内存回收的速度赶不上内存分配的速度，
G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间“Stop The World”。</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>怎样建立起可靠的停顿预测模型？</strong></p>
<div class="ulist">
<ul>
<li>
<p>用户通过-XX：MaxGCPauseMillis参数指定的停顿时间只意味着垃圾收集发生之前的期望值，但G1收集器要怎么做才能满足用户的期望呢？G1收集器的停顿预测模型是以衰减均值为理论基础来实现的，在垃圾收集过程中，G1收集器会记录每个Region的回收耗时，每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，
并分析得出平均值、标准偏差、置信度等统计信息。平均值代表整体平均状态，但衰减平均值更准确地代表“最近的”平均状态。换句话说，Region的统计状态越新越能决定其回收的价值。然后通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_数据结构"><a class="anchor" href="#_数据结构"></a>1.2.3. 数据结构</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Remembered Sets</strong> 简称 RSets. RSet记录了其他Region中的对象引用本Region中对象的关系. RSet的价值在于使得垃圾收集器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可. 堆内存中的每个region都有一个RSet. RSet 使heap区能并行独立地进行垃圾集合. RSets的总体影响小于5%.</p>
</li>
<li>
<p><strong>Collection Sets</strong> 简称 CSets. 收集集合,一组可被回收的分区的集合。在CSet中存活的数据会在GC过程中被移动到另一个可用分区，CSet中的分区可以来自Eden空间、survivor空间、或者老年代。CSet会占用不到整个堆空间的1%大小</p>
</li>
<li>
<p><strong>SATB算法</strong> 快照标记算法</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>如果我们不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作），G1收集器的
运作过程大致可划分为以下四个步骤：</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS
指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要
停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际
并没有额外的停顿。</p>
</li>
<li>
<p>并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆
里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以
后，还要重新处理SATB记录下的在并发时有引用变动的对象。</p>
</li>
<li>
<p>最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留
下来的最后那少量的SATB记录。</p>
</li>
<li>
<p>筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回
收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region
构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧
Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行
完成的。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/g1Running.png" alt="g1Running">
</div>
</div>
<div class="paragraph">
<p><strong>G1与CMS对比优势与劣势</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>可以指定最大停顿时间</p>
</li>
<li>
<p>分Region的内存布局</p>
</li>
<li>
<p>按收益动态确定回收集</p>
</li>
<li>
<p>不会产生内存空间碎片：单从最传统的算法理论上看，G1也更有发展潜力。与CMS
的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region
之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存
空间碎片</p>
</li>
<li>
<p>在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载都要比CMS要高</p>
</li>
<li>
<p>G1的卡表实现更为复杂，占用堆空间更多。堆中每个Region，无论扮演的是新生代还是老年代角色，都必须有一份卡表，这导致G1的记忆集（和
其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间；相比起来CMS的卡表就相当简单，
只有唯一一份，而且只需要处理老年代到新生代的引用，反过来则不需要，由于新生代的对象具有朝
生夕灭的不稳定性，引用变化频繁，能省下这个区域的维护开销是很划算的</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-01-22 12:19:55 UTC
</div>
</div>
</body>
</html>