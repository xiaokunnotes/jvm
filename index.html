<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<meta name="keywords" content="Java,JDK,Java source,Collection,ArrayList,Map,List,HashMap,ArrayDeque,Deque,Set,HashSet,LinkedList,Queue,TreeMap,TreeSet,Vector,Stack">
<meta name="author" content="2020-12-24">
<meta name="copyright" content="Apache-2.0">
<title>深入理解JVM虚拟机</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="assets/css/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="assets/css/rouge-monokai.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>深入理解JVM虚拟机</h1>
<div class="details">
<span id="author" class="author">2020-12-24</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_前言">前言</a></li>
<li><a href="#_第二部分_自动内存管理实践">1. 第二部分 自动内存管理实践</a></li>
<li><a href="#_第二部分_虚拟机对象探秘">2. 第二部分 虚拟机对象探秘</a></li>
<li><a href="#_第三部分_如何确定对象是存活还是死亡">3. 第三部分 如何确定对象是存活还是死亡</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_前言"><a class="anchor" href="#_前言"></a>前言</h2>
<div class="sectionbody">
<div class="paragraph">
<p>为了更好的理解jvm运行机制，在工作上每每写完一个功能的代码后再做一步Jvm的性能调优，就像每次执行代码规范检查一样。
会让你的系统更健壮。</p>
</div>
<div class="paragraph">
<p>整体内容算是学习这本《深入理解JVM虚拟机》的阅读笔记，所以整个目录结构也是跟这个书保持了一致，相信一切都是最好的安排</p>
</div>
<div class="paragraph">
<p>欢迎指出日志中不足的地方，包含错误或者描述不清的地方。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二部分_自动内存管理实践"><a class="anchor" href="#_第二部分_自动内存管理实践"></a>1. 第二部分 自动内存管理实践</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="./../images/runing.png" alt="runing">
</div>
</div>
<div class="sect2">
<h3 id="_程序计数器program_counter_register"><a class="anchor" href="#_程序计数器program_counter_register"></a>1.1. 程序计数器（Program Counter Register）</h3>
<div class="paragraph">
<p>程序计数器主要存储当前线程所执行的字节码行号指示器，通过改变计数器的值来获取下一条需要执行的字节码指令。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>首先我们要搞清楚JVM的多线程实现方式。JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，在JVM中，通过程序计数器来记录某个线程的字节码执行位置。因此，程序计数器是具备线程隔离的特性，也就是说，每个线程工作时都有属于自己的独立计数器。</pre>
</div>
</div>
<div class="paragraph">
<p>特点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>线程隔离性,每个线程有自己的独立技术器。</p>
</li>
<li>
<p>执行java方法时，计数器中记录的是正在执行的虚拟机字节码指令地址</p>
</li>
<li>
<p>执行native方法时，计数器值为空。why? native方法大多是通过C实现的并未编译成需要执行的字节码指令，也就不需要存储执行指令地址了。</p>
</li>
<li>
<p>jvm规范中唯一没有规定OutOfMemoryError情况的区域</p>
</li>
<li>
<p>占用内存很小，可忽略不计</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_虚拟机栈vm_stack"><a class="anchor" href="#_虚拟机栈vm_stack"></a>1.2. 虚拟机栈（VM Stack）</h3>
<div class="paragraph">
<p>虚拟机栈描述的是Java方法执行的线程内存模型，存放的是一个方法的所有局部变量。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>每个方法被执行的时候，虚拟机栈都会同步创建一个栈帧（Stack Frame） 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完毕的过程就对应着一个栈帧在虚拟机中从入栈到出栈的过程</pre>
</div>
</div>
<div class="paragraph">
<p>下面我们用这段代码介绍下虚拟机栈结构及用途</p>
</div>
<div class="listingblock">
<div class="title">VmStackDome.java</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="java"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">VmStackDome</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">methodOne</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">){</span>

      <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
      <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">;</span>
      <span class="nc">Object</span> <span class="n">object</span> <span class="o">=</span> <span class="n">obj</span><span class="o">;</span>
      <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
      <span class="n">methodTwo</span><span class="o">();</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">methodTwo</span><span class="o">(){</span>
      <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"k="</span><span class="o">+</span><span class="n">k</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>当虚拟机要执行一个方法methodOne()时，就会有一个栈帧压入线程独享的虚拟机栈中，如下图</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/ruzhanguocheng.png" alt="ruzhanguocheng">
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>当线程开始执行这个方法时这些局部变量应该从哪里读取，又是在哪里做的运算？我们通过看这个类的反编译代码来看</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/bianyi.png" alt="bianyi">
</div>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>我们直接看这个方法的执行区，可以看到在执行int j=1;时对应的执行指令是iconst_1,我们再参考Java虚拟机字节码指令表看，iconst_1的含义是将int型1推送至栈顶</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/iconst_1.png" alt="iconst 1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/iconst_1-2.png" alt="iconst 1 2">
</div>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>执行istore_2指令,指令含义：将栈顶int型数值存入第三个本地变量</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/istore.png" alt="istore">
</div>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>执行iload_1指令（将第二个int型本地变量推送至栈顶）、iload_2（将第三个int型本地变量推送至栈顶）假设 i=10;</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/iload.png" alt="iload">
</div>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>执行iadd指令(将栈顶两int型数值相加并将结果压入栈顶)、执行istore_3（将栈顶int型数值存入第四个本地变量）</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/iadd.png" alt="iadd">
</div>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>接下来执行istore_3指令（将栈顶int型数值存入第四个本地变量）</p>
</li>
<li>
<p>接下来执行getstatic指令（获取指定类的静态域, 并将其压入栈顶）</p>
</li>
<li>
<p>思考一个问题，执行字节码指令是哪个组件在执行？</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>答案是：执行引擎，它负责执行虚拟机的字节码，现代虚拟机为了提高执行效率，会使用即时编译(just in time)技术将方法编译成机器码后再执行。</p>
</li>
<li>
<p>Java HotSpot Client VM(-client)，为在客户端环境中减少启动时间而优化的执行引擎；本地应用开发使用。（如：eclipse）</p>
</li>
<li>
<p>Java HotSpot Server VM(-server)，为在服务器环境中最大化程序执行速度而设计的执行引擎。应用在服务端程序。（如：tomcat）</p>
</li>
<li>
<p>Java HotSpot Client模式和Server模式的区别</p>
<div class="olist upperalpha">
<ol class="upperalpha" type="A">
<li>
<p>当虚拟机运行在-client模式的时候,使用的是一个代号为C1的轻量级编译器, 而-server模式启动的虚拟机采用相对重量级,代号为C2的编译器. C2比C1编译器编译的相对彻底,服务起来之后,性能更高。JDK安装目录/jre/lib/（x86、i386、amd32、amd64）/jvm.cfg文件中的内容，-server和-client哪一个配置在上，执行引擎就是哪一个。如果是JDK1.5版本且是64位系统应用时，-client无效。在部分JDK1.6版本和后续的JDK版本(64位系统)中，-client参数已经不起作用了，Server模式成为唯一。</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_本地方法栈native_method_stacks"><a class="anchor" href="#_本地方法栈native_method_stacks"></a>1.3. 本地方法栈（Native Method Stacks）</h3>
<div class="paragraph">
<p>与虚拟机所发挥的作用是非常相似的，其区别是虚拟机为本地Java方法执行字节码服务，本地方法栈为native方法执行字节码服务</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/nativeMethod.png" alt="nativeMethod">
</div>
</div>
<div class="paragraph">
<p>该线程首先调用了两个Java方法，而第二个Java方法又调用了一个本地方法，这样导致虚拟机使用了一个本地方法栈。假设这是一个C语言栈，其间有两个C函数，第一个C函数被第二个Java方法当做本地方法调用，而这个C函数又调用了第二个C函数。之后第二个C函数又通过本地方法接口回调了一个Java方法（第三个Java方法），最终这个Java方法又调用了一个Java方法</p>
</div>
</div>
<div class="sect2">
<h3 id="_堆heap"><a class="anchor" href="#_堆heap"></a>1.4. 堆（Heap）</h3>
<div class="paragraph">
<p>此内存区域唯一目的就是存放对象实例，Java世界里几乎所有的对象的实例都在这里分配内存。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Java虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代和永久代（对HotSpot虚拟机而言），这就是JVM的内存分代策略。
   堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收最频繁的一块区域，我们程序所有的对象实例都存放在堆内存中。给堆内存分代是为了提高对象内存分配和垃圾回收的效率。试想一下，如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾收集，而每次回收都要遍历所有的对象，遍历这些对象所花费的时间代价是巨大的，会严重影响我们的GC效率。
   有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经过多次回收仍然存活下来的对象存放在老年代中，静态属性、类信息等存放在永久代中，新生代中的对象存活时间短，只需要在新生代区域中频繁进行GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收，永久代中回收效果太差，一般不进行垃圾回收，还可以根据不同年代的特点采用合适的垃圾收集算法。分代收集大大提升了收集效率，这些都是内存分代带来的好处。
   当前主流的Java堆都是可扩展的，通过-Xmx和-Xms设定的，如果堆中没有内存完成实例分配也无法再扩展时，jvm就会抛出OutOfMemoryError异常</pre>
</div>
</div>
<div class="paragraph">
<p>特点</p>
</div>
<div class="ulist">
<ul>
<li>
<p>线程共享的一块区域</p>
</li>
<li>
<p>可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）已提升分配对象时的效率</p>
</li>
<li>
<p>堆可以处于物理上不连续的区域，但逻辑上是连续的。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/neicunfendai.png" alt="neicunfendai">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_方法区method_area"><a class="anchor" href="#_方法区method_area"></a>1.5. 方法区（Method Area）</h3>
<div class="paragraph">
<p>它用于存储已被虚拟机加载的类型信息(class)、常量、静态变量、即时编译后的代码缓存等数据。
jdk1.8之后元空间实现了方法区，使用内存区域是本地内存。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>方法区 ≠ 永久代/元空间。 方法区只是一种逻辑上的概念，是一中规范，而永久代/元空间是实现层面的东西，指物理上的一块空间。元空间并不在虚拟机中，而是使用本机内存，元空间大小仅受本地内存限制。</pre>
</div>
</div>
<div class="paragraph">
<p>特点</p>
</div>
<div class="ulist">
<ul>
<li>
<p>线程共享的一块区域</p>
</li>
<li>
<p>jdk8之后实现层是元空间，不属于虚拟机，直接占用本机内存。</p>
</li>
<li>
<p>jdk7叫永久代，已经把原本放在永久代的字符串常量池、静态变量移出，</p>
</li>
<li>
<p>jdk6永久代全部属于堆空间</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_运行时常量池runtime_constant_pool"><a class="anchor" href="#_运行时常量池runtime_constant_pool"></a>1.6. 运行时常量池（Runtime Constant Pool）</h3>
<div class="paragraph">
<p>存储常量池表&#8212;&#8203;编译期生成的各种字面量与符号引用。这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/yunxingshichangliangchi.png" alt="yunxingshichangliangchi">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二部分_虚拟机对象探秘"><a class="anchor" href="#_第二部分_虚拟机对象探秘"></a>2. 第二部分 虚拟机对象探秘</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_对象的创建"><a class="anchor" href="#_对象的创建"></a>2.1. 对象的创建</h3>
<div class="paragraph">
<p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到
一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那
必须先执行相应的类加载过程，后面还会详细的探讨这部分细节。</p>
</div>
</div>
<div class="sect2">
<h3 id="_对象的内存布局"><a class="anchor" href="#_对象的内存布局"></a>2.2. 对象的内存布局</h3>
<div class="paragraph">
<p>对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例
数据（Instance Data）和对齐填充（Padding）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_对象的访问定位"><a class="anchor" href="#_对象的访问定位"></a>2.3. 对象的访问定位</h3>
<div class="paragraph">
<p>创建对象自然是为了后续使用该对象，我们的Java程序会通过栈上的reference数据来操作堆上的具
体对象。由于reference类型在《Java虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义
这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实
现而定的，主流的访问方式主要有使用句柄和直接指针两种</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第三部分_如何确定对象是存活还是死亡"><a class="anchor" href="#_第三部分_如何确定对象是存活还是死亡"></a>3. 第三部分 如何确定对象是存活还是死亡</h2>
<div class="sectionbody">
<div class="paragraph">
<p>前面了解了Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，栈
中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基
本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，
在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着
回收了。</p>
</div>
<div class="paragraph">
<p>但是`堆` 和`方法区`则有着很显著的不确定性：一个接口的多个实现类需要的内存可能不一样，一个方法所执行的不同条件，
只有处于运行期我们才能知道程序究竟会创建哪些对象，这部分内存的分配和回收是动态的。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">说起垃圾收集我们需要考虑三个问题</dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>哪些内存需要回收？</p>
</li>
<li>
<p>什么时候回收？</p>
</li>
<li>
<p>如何回收？</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_引用计算算法reference_counting"><a class="anchor" href="#_引用计算算法reference_counting"></a>3.1. 引用计算算法（Reference Counting）</h3>
<div class="paragraph">
<p>对每个对象的引用进行计数，每当有一个地方引用它时计数器 +1、引用失效则 -1，引用的计数放到对象头中，大于 0 的对象被认为是存活对象。
在Java领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。
循环引用的问题可通过 Recycler 算法解决，但是在多线程环境下，引用计数变更也要进行昂贵的同步操作，性能较低，早期的编程语言会采用此算法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_可达性分析reachability_analysis"><a class="anchor" href="#_可达性分析reachability_analysis"></a>3.2. 可达性分析（Reachability Analysis）</h3>
<div class="paragraph">
<p>这个算法的基本思路就是通过
一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过
程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，
或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的</p>
</div>
<div class="paragraph">
<p>如图下图所示，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，
因此它们将会被判定为可回收的对象。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/roots.png" alt="roots">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">在Java技术体系里面，固定可作为GC Roots的对象包括以下几种</dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的
参数、局部变量、临时变量等。</p>
</li>
<li>
<p>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</p>
</li>
<li>
<p>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</p>
</li>
<li>
<p>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</p>
</li>
<li>
<p>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如
NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</p>
</li>
<li>
<p>所有被同步锁（synchronized关键字）持有的对象。</p>
</li>
<li>
<p>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p>
</li>
</ol>
</div>
</dd>
<dt class="hdlist1">在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段。要真正宣告一个对象死亡，至少要经历两次标记过程</dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记,</p>
</li>
<li>
<p>判断是否需要筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用
过，那么虚拟机将这两种情况都视为“没有必要执行”。翻译成代码：</p>
<div class="literalblock">
<div class="content">
<pre> ----
if(对象没有覆盖finalize()方法 || finalize()方法已经被虚拟机调用过){
     //没有必要执行finalize();
}else{
    //对象进入 F-Queue......
}
 ----</pre>
</div>
</div>
</li>
<li>
<p>如果这个对象被判定为有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue队列中，
然后虚拟机自动建立低调度优先级的Finalizer线程去执行他们的finalize()方法。（触发其开始运行，但并不承诺一定会等待它运行结束，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导
致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃）</p>
</li>
<li>
<p>第二次标记：收集器将对F-Queue中的对象进行第二次小规模的标记。如果对
象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己
（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集
合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kn">package</span> <span class="nn">com.jinkun.jvm.notes</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FinalizeEscapeGC</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="nc">FinalizeEscapeGC</span> <span class="no">SAVE_HOOK</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">finalize</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">finalize</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"finalize method executed!"</span><span class="o">);</span>
    <span class="nc">FinalizeEscapeGC</span><span class="o">.</span><span class="na">SAVE_HOOK</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
    <span class="no">SAVE_HOOK</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FinalizeEscapeGC</span><span class="o">();</span>
    <span class="c1">//对象第一次成功拯救自己</span>
    <span class="no">SAVE_HOOK</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">gc</span><span class="o">();</span>
    <span class="c1">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="no">SAVE_HOOK</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"yes, i am still alive :"</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"no, i am dead :("</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span>
    <span class="no">SAVE_HOOK</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">gc</span><span class="o">();</span>
    <span class="c1">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="no">SAVE_HOOK</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"yes, i am still alive :"</span><span class="o">+</span><span class="no">SAVE_HOOK</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"no, i am dead :"</span><span class="o">+</span><span class="no">SAVE_HOOK</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>运行结果：
finalize method executed!
yes, i am still alive :
no, i am dead :(</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_标记清除法mark_sweep"><a class="anchor" href="#_标记清除法mark_sweep"></a>3.3. 标记清除法（Mark-Sweep）</h3>
<div class="paragraph">
<p>标记清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象</p>
</div>
<div class="paragraph">
<p>入下图：使用标记清除算法对一块连续的内存空间进行回收。从根节点开始（这里显示了2个根），所有的有引用关系的对象均被标记为存活对象（箭头表示引用）。从根节点起，不可达的对象均为垃圾对象。在标记操作完成后，系统回收所有不可达的空间。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./../images/bjqc.png" alt="bjqc">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>该算法最大的缺点就是：回收后的空间是不连续的。在对象的空间分配过程中，尤其是大对象的内存分配，不连续的内存空间的工作效率要低于连续的空间。因此这也是该算法的最大缺点。优化升级版是：标记压缩法。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_复制算法copying"><a class="anchor" href="#_复制算法copying"></a>3.4. 复制算法(Copying)</h3>
<div class="paragraph">
<p>复制算法的核心思想是：将原来的内存空间分为两块，每次只使用其中一块，在进行垃圾回收时将正在使用的那块区域中存活对象复制到未使用的内存块中，之后清楚正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。</p>
</div>
<div class="paragraph">
<p>如图所示：A、B两块相同的内存空间，A在进行垃圾回收时，将存活对象复制到B中，B中的空间在复制后保持连续。复制完成后清空A，并将B空间设置为当前使用空间。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./../images/fuzhisuanfa.png" alt="fuzhisuanfa">
</div>
</div>
<div class="paragraph">
<p>在java的新生代串行垃圾回收器中使用了复制算法的思想，新生代分为eden空间、from空间和to空间3个部分。其中from和to空间可视为用于复制的两块大小相同、地位相等且可进行角色互换的空间快。如下图</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./../images/fzsf.png" alt="fzsf">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_标记压缩法mark_compact"><a class="anchor" href="#_标记压缩法mark_compact"></a>3.5. 标记压缩法（Mark-Compact）</h3>
<div class="paragraph">
<p>标记清除算法在标记压缩算法的基础上做了一些优化，等同于标记清除算法执行完成后再进行一次内存碎片整理，因此也叫标记清理压缩算法（MarkSweepCompact）。</p>
</div>
<div class="paragraph">
<p>标记压缩算法也首先需要从根节点开始，对所有可达对象做一次标记。但之后它并不只是简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后清理边界所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此性价比非常高。</p>
</div>
<div class="paragraph">
<p>如下图：通过跟节点标记出所有可达对象后，沿虚线进行对象移动，将所有的可达对象都移动到一端，并保持他们之间的引用关系，最后清理边界外的空间，即可完成回收工作。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./../images/bjys.png" alt="bjys">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_分代收集理论分代算法generational_collectiong"><a class="anchor" href="#_分代收集理论分代算法generational_collectiong"></a>3.6. 分代收集理论&#8212;&#8203;分代算法（Generational Collectiong）</h3>
<div class="paragraph">
<p>分代算法的思想就是：内存区间根据对象的特点分为几块，根据每块内存区间的特点使用不同的回收算法，以提高垃圾回收的效率，一般会分成新生代和老年代两个区域。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>新生代：Java虚拟机会将所有的新建对象都放入新生代的内存区域，新生代的特点是对象朝生夕灭，大约90%的对象都会被很快回收，因此新生代比较适合使用复制算法。</p>
</li>
<li>
<p>老年代：当一个对象经过几次回收后依然存活，对象就会被放入老年代的内存空间。在老年代中，几乎所有的对象都是经过几次垃圾回收后依然存活的。因此，可以认为这些对象在一段时期内、甚至在应用程序的整个生命周期中，都将是常驻内存的。如果依然使用复制算法回收老年代将需要复制大量对象，回收性价比远远低于新生代，因此老年代比较适合使用标记清除压缩算法。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>但是这样会产生一个问题，年轻代中发生minor gc的频率很高，经常会扫描年轻代中的对象进行标记，如果老年代中有对象引用了年轻代中的对象，那岂不是每次进行minor gc时也要进行全堆的扫描？所以为了支持高频率的新生代回收，同时又避免把整个来年代加进GC Roots扫描范围，虚拟机会使用一种叫做卡表的数据结构来记录老年代引用新生代的关系。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>记忆集&#8212;&#8203;卡表</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集的数据结构。用于避免把整个老年代加进GC Roots扫描范围。</p>
</div>
<div class="paragraph">
<p><code>记忆集</code> 是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。</p>
</div>
<div class="paragraph">
<p><code>卡表</code> 卡表就是记忆集的一种具体实现（可以理解为hashMap与Map的关系），卡表是一个比特位集合，它定义了记忆集的记录精度、与堆内存的映射关系。每一个比特位可以用来表示老年代的某一区域中所有对象是否持有新生代对象的引用。这样在新生代GC时可以不用花大量时间扫描所有的老年代对象来确定每一个对象的引用关系，可以先扫码卡表
只有当卡表的标记位为1时，才需要扫码给定区域的老年代对象，而卡表为0的老年代对象，一定不含有新生代对象的引用。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./../images/cardTable.png" alt="cardTable">
</div>
</div>
<div class="paragraph">
<p>以Hotspot虚拟机为例，卡表的设计，是将整个堆空间分割成一个个卡页（card page），每个卡页大小为512字节（其他虚拟机也基本都为2的n次幂），而卡表本事为一个简单的字节数组，记录当前对应卡页的标记值。当判断一个卡页中有存在对象的夸代引用时，将这个页标记为脏页，在进行 Minor GC 的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./../images/card.png" alt="card">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_写屏障"><a class="anchor" href="#_写屏障"></a>3.7. 写屏障</h3>
<div class="literalblock">
<div class="content">
<pre>  我们已经解决了如何使用记忆集来缩减GC Roots扫描范围的问题，但还没有解决卡表元素如何维护的问题，例如它们何时变脏、谁来把它们变脏等？
  卡表元素何时变脏的答案是很明确的——有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻。但问题是如何变
脏，即如何在对象赋值的那一刻去更新维护卡表呢？</pre>
</div>
</div>
<div class="paragraph">
<p>写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环形通知，供程序执行额外的动作，也就是说赋值的
前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫作写前屏障，在赋值后的则叫作写后屏障。G1收集器出现之前其他收集器都只用到了写后屏障。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>void oop_field_store(oop* field, oop new_value) {
// 引用字段赋值操作
*field = new_value;
// 写后屏障，在这里完成卡表状态更新
post_write_barrier(field, new_value);
}</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_伪共享"><a class="anchor" href="#_伪共享"></a>3.8. 伪共享</h3>
<div class="paragraph">
<p>除了写屏障的开销外，卡表在高并发场景下还面临着“伪共享”（False Sharing）问题。伪共享是处理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行（Cache Line） 为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>假设处理器的缓存行大小为64字节，由于一个卡表元素占1个字节，64个卡表元素将共享同一个缓存行。这64个卡表元素对应的卡页总的内存为32KB（64×512字节），也就是说如果不同线程更新的对象正好处于这32KB的内存区域内，就会导致更新卡表时正好写入同一个缓存行而影响性能</pre>
</div>
</div>
<div class="paragraph">
<p>解决方案：一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏;</p>
</div>
<div class="paragraph">
<p>在JDK 7之后，HotSpot虚拟机增加了一个新的参数-XX：+UseCondCardMark，用来决定是否开启卡表更新的条件判断。开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损耗，是否打开要根据应用实际运行情况来进行测试权衡。</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-12-24 09:50:26 UTC
</div>
</div>
</body>
</html>