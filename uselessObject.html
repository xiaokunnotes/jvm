<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<title>第三部分 如何确定对象是存活还是死亡</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="assets/css/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="assets/css/rouge-monokai.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>第三部分 如何确定对象是存活还是死亡</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_引用计算算法reference_counting">1. 引用计算算法（Reference Counting）</a></li>
<li><a href="#_可达性分析reachability_analysis">2. 可达性分析（Reachability Analysis）</a></li>
<li><a href="#_标记清除法mark_sweep">3. 标记清除法（Mark-Sweep）</a></li>
<li><a href="#_复制算法copying">4. 复制算法(Copying)</a></li>
<li><a href="#_标记压缩法mark_compact">5. 标记压缩法（Mark-Compact）</a></li>
<li><a href="#_分代收集理论分代算法generational_collectiong">6. 分代收集理论&#8212;&#8203;分代算法（Generational Collectiong）</a></li>
<li><a href="#_写屏障">7. 写屏障</a></li>
<li><a href="#_伪共享">8. 伪共享</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>前面了解了Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，栈
中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基
本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，
在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着
回收了。</p>
</div>
<div class="paragraph">
<p>但是`堆` 和`方法区`则有着很显著的不确定性：一个接口的多个实现类需要的内存可能不一样，一个方法所执行的不同条件，
只有处于运行期我们才能知道程序究竟会创建哪些对象，这部分内存的分配和回收是动态的。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">说起垃圾收集我们需要考虑三个问题</dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>哪些内存需要回收？</p>
</li>
<li>
<p>什么时候回收？</p>
</li>
<li>
<p>如何回收？</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_引用计算算法reference_counting"><a class="anchor" href="#_引用计算算法reference_counting"></a>1. 引用计算算法（Reference Counting）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>对每个对象的引用进行计数，每当有一个地方引用它时计数器 +1、引用失效则 -1，引用的计数放到对象头中，大于 0 的对象被认为是存活对象。
在Java领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。
循环引用的问题可通过 Recycler 算法解决，但是在多线程环境下，引用计数变更也要进行昂贵的同步操作，性能较低，早期的编程语言会采用此算法。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_可达性分析reachability_analysis"><a class="anchor" href="#_可达性分析reachability_analysis"></a>2. 可达性分析（Reachability Analysis）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这个算法的基本思路就是通过
一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过
程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，
或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的</p>
</div>
<div class="paragraph">
<p>如图下图所示，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，
因此它们将会被判定为可回收的对象。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/roots.png" alt="roots">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">在Java技术体系里面，固定可作为GC Roots的对象包括以下几种</dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的
参数、局部变量、临时变量等。</p>
</li>
<li>
<p>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</p>
</li>
<li>
<p>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</p>
</li>
<li>
<p>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</p>
</li>
<li>
<p>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如
NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</p>
</li>
<li>
<p>所有被同步锁（synchronized关键字）持有的对象。</p>
</li>
<li>
<p>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p>
</li>
</ol>
</div>
</dd>
<dt class="hdlist1">在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段。要真正宣告一个对象死亡，至少要经历两次标记过程</dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记,</p>
</li>
<li>
<p>判断是否需要筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用
过，那么虚拟机将这两种情况都视为“没有必要执行”。翻译成代码：</p>
<div class="literalblock">
<div class="content">
<pre> ----
if(对象没有覆盖finalize()方法 || finalize()方法已经被虚拟机调用过){
     //没有必要执行finalize();
}else{
    //对象进入 F-Queue......
}
 ----</pre>
</div>
</div>
</li>
<li>
<p>如果这个对象被判定为有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue队列中，
然后虚拟机自动建立低调度优先级的Finalizer线程去执行他们的finalize()方法。（触发其开始运行，但并不承诺一定会等待它运行结束，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导
致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃）</p>
</li>
<li>
<p>第二次标记：收集器将对F-Queue中的对象进行第二次小规模的标记。如果对
象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己
（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集
合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kn">package</span> <span class="nn">com.jinkun.jvm.notes</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FinalizeEscapeGC</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="nc">FinalizeEscapeGC</span> <span class="no">SAVE_HOOK</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">finalize</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">finalize</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"finalize method executed!"</span><span class="o">);</span>
    <span class="nc">FinalizeEscapeGC</span><span class="o">.</span><span class="na">SAVE_HOOK</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
    <span class="no">SAVE_HOOK</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FinalizeEscapeGC</span><span class="o">();</span>
    <span class="c1">//对象第一次成功拯救自己</span>
    <span class="no">SAVE_HOOK</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">gc</span><span class="o">();</span>
    <span class="c1">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="no">SAVE_HOOK</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"yes, i am still alive :"</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"no, i am dead :("</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span>
    <span class="no">SAVE_HOOK</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">gc</span><span class="o">();</span>
    <span class="c1">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="no">SAVE_HOOK</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"yes, i am still alive :"</span><span class="o">+</span><span class="no">SAVE_HOOK</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"no, i am dead :"</span><span class="o">+</span><span class="no">SAVE_HOOK</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>运行结果：
finalize method executed!
yes, i am still alive :
no, i am dead :(</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_标记清除法mark_sweep"><a class="anchor" href="#_标记清除法mark_sweep"></a>3. 标记清除法（Mark-Sweep）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>标记清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象</p>
</div>
<div class="paragraph">
<p>入下图：使用标记清除算法对一块连续的内存空间进行回收。从根节点开始（这里显示了2个根），所有的有引用关系的对象均被标记为存活对象（箭头表示引用）。从根节点起，不可达的对象均为垃圾对象。在标记操作完成后，系统回收所有不可达的空间。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./../images/bjqc.png" alt="bjqc">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>该算法最大的缺点就是：回收后的空间是不连续的。在对象的空间分配过程中，尤其是大对象的内存分配，不连续的内存空间的工作效率要低于连续的空间。因此这也是该算法的最大缺点。优化升级版是：标记压缩法。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_复制算法copying"><a class="anchor" href="#_复制算法copying"></a>4. 复制算法(Copying)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>复制算法的核心思想是：将原来的内存空间分为两块，每次只使用其中一块，在进行垃圾回收时将正在使用的那块区域中存活对象复制到未使用的内存块中，之后清楚正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。</p>
</div>
<div class="paragraph">
<p>如图所示：A、B两块相同的内存空间，A在进行垃圾回收时，将存活对象复制到B中，B中的空间在复制后保持连续。复制完成后清空A，并将B空间设置为当前使用空间。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/fuzhisuanfa.png" alt="fuzhisuanfa">
</div>
</div>
<div class="paragraph">
<p>在java的新生代串行垃圾回收器中使用了复制算法的思想，新生代分为eden空间、from空间和to空间3个部分。其中from和to空间可视为用于复制的两块大小相同、地位相等且可进行角色互换的空间快。如下图</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./../images/fzsf.png" alt="fzsf">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_标记压缩法mark_compact"><a class="anchor" href="#_标记压缩法mark_compact"></a>5. 标记压缩法（Mark-Compact）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>标记清除算法在标记压缩算法的基础上做了一些优化，等同于标记清除算法执行完成后再进行一次内存碎片整理，因此也叫标记清理压缩算法（MarkSweepCompact）。</p>
</div>
<div class="paragraph">
<p>标记压缩算法也首先需要从根节点开始，对所有可达对象做一次标记。但之后它并不只是简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后清理边界所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此性价比非常高。</p>
</div>
<div class="paragraph">
<p>如下图：通过跟节点标记出所有可达对象后，沿虚线进行对象移动，将所有的可达对象都移动到一端，并保持他们之间的引用关系，最后清理边界外的空间，即可完成回收工作。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/bjys.png" alt="bjys">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_分代收集理论分代算法generational_collectiong"><a class="anchor" href="#_分代收集理论分代算法generational_collectiong"></a>6. 分代收集理论&#8212;&#8203;分代算法（Generational Collectiong）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>分代算法的思想就是：内存区间根据对象的特点分为几块，根据每块内存区间的特点使用不同的回收算法，以提高垃圾回收的效率，一般会分成新生代和老年代两个区域。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>新生代：Java虚拟机会将所有的新建对象都放入新生代的内存区域，新生代的特点是对象朝生夕灭，大约90%的对象都会被很快回收，因此新生代比较适合使用复制算法。</p>
</li>
<li>
<p>老年代：当一个对象经过几次回收后依然存活，对象就会被放入老年代的内存空间。在老年代中，几乎所有的对象都是经过几次垃圾回收后依然存活的。因此，可以认为这些对象在一段时期内、甚至在应用程序的整个生命周期中，都将是常驻内存的。如果依然使用复制算法回收老年代将需要复制大量对象，回收性价比远远低于新生代，因此老年代比较适合使用标记清除压缩算法。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>但是这样会产生一个问题，年轻代中发生minor gc的频率很高，经常会扫描年轻代中的对象进行标记，如果老年代中有对象引用了年轻代中的对象，那岂不是每次进行minor gc时也要进行全堆的扫描？所以为了支持高频率的新生代回收，同时又避免把整个来年代加进GC Roots扫描范围，虚拟机会使用一种叫做卡表的数据结构来记录老年代引用新生代的关系。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>记忆集&#8212;&#8203;卡表</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集的数据结构。用于避免把整个老年代加进GC Roots扫描范围。</p>
</div>
<div class="paragraph">
<p><code>记忆集</code> 是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。</p>
</div>
<div class="paragraph">
<p><code>卡表</code> 卡表就是记忆集的一种具体实现（可以理解为hashMap与Map的关系），卡表是一个比特位集合，它定义了记忆集的记录精度、与堆内存的映射关系。每一个比特位可以用来表示老年代的某一区域中所有对象是否持有新生代对象的引用。这样在新生代GC时可以不用花大量时间扫描所有的老年代对象来确定每一个对象的引用关系，可以先扫码卡表
只有当卡表的标记位为1时，才需要扫码给定区域的老年代对象，而卡表为0的老年代对象，一定不含有新生代对象的引用。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/cardTable.png" alt="cardTable">
</div>
</div>
<div class="paragraph">
<p>以Hotspot虚拟机为例，卡表的设计，是将整个堆空间分割成一个个卡页（card page），每个卡页大小为512字节（其他虚拟机也基本都为2的n次幂），而卡表本事为一个简单的字节数组，记录当前对应卡页的标记值。当判断一个卡页中有存在对象的夸代引用时，将这个页标记为脏页，在进行 Minor GC 的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/card.png" alt="card">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_写屏障"><a class="anchor" href="#_写屏障"></a>7. 写屏障</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>  我们已经解决了如何使用记忆集来缩减GC Roots扫描范围的问题，但还没有解决卡表元素如何维护的问题，例如它们何时变脏、谁来把它们变脏等？
  卡表元素何时变脏的答案是很明确的——有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻。但问题是如何变
脏，即如何在对象赋值的那一刻去更新维护卡表呢？</pre>
</div>
</div>
<div class="paragraph">
<p>写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环形通知，供程序执行额外的动作，也就是说赋值的
前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫作写前屏障，在赋值后的则叫作写后屏障。G1收集器出现之前其他收集器都只用到了写后屏障。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>void oop_field_store(oop* field, oop new_value) {
// 引用字段赋值操作
*field = new_value;
// 写后屏障，在这里完成卡表状态更新
post_write_barrier(field, new_value);
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_伪共享"><a class="anchor" href="#_伪共享"></a>8. 伪共享</h2>
<div class="sectionbody">
<div class="paragraph">
<p>除了写屏障的开销外，卡表在高并发场景下还面临着“伪共享”（False Sharing）问题。伪共享是处理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行（Cache Line） 为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>假设处理器的缓存行大小为64字节，由于一个卡表元素占1个字节，64个卡表元素将共享同一个缓存行。这64个卡表元素对应的卡页总的内存为32KB（64×512字节），也就是说如果不同线程更新的对象正好处于这32KB的内存区域内，就会导致更新卡表时正好写入同一个缓存行而影响性能</pre>
</div>
</div>
<div class="paragraph">
<p>解决方案：一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏;</p>
</div>
<div class="paragraph">
<p>在JDK 7之后，HotSpot虚拟机增加了一个新的参数-XX：+UseCondCardMark，用来决定是否开启卡表更新的条件判断。开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损耗，是否打开要根据应用实际运行情况来进行测试权衡。</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-01-14 01:25:24 UTC
</div>
</div>
</body>
</html>